/*
 * Project: Sudoku Explainer
 * Copyright (C) 2006-2007 Nicolas Juillerat
 * Copyright (C) 2013-2020 Keith Corlett
 * Available under the terms of the Lesser General Public License (LGPL)
 */
package diuf.sudoku.solver.hinters.als;

import diuf.sudoku.Grid;
import diuf.sudoku.Grid.ARegion;
import diuf.sudoku.Grid.Cell;
import diuf.sudoku.Idx;
import diuf.sudoku.Values;
import diuf.sudoku.utils.Frmt;

/**
 * NOTE: The hints contain DiufAls's but the hinters use HdkAls's internally!
 *
 * An ALS (Almost Locked Set) has 1 more maybes than cells; so if one value was
 * eliminated it'd be a Locked Set (a Naked Pair, or whatever). <br>
 * More formally, an Almost Locked Set is N cells with N+1 potential values.
 * By this definition a bi-value cell IS an ALS, but we ignore them.
 * <p>
 * AlmostLockedSet currently taking ALS's out to 5 cells sharing 6 values.
 * Experience tells me that as the sets increase in size they both become more
 * expensive to compute and less likely to occur; so size-usefulness is an
 * exponential cost-benefit curve, so I tap-out early.
 * <p>
 * Later I might take it out to 6 cells sharing 7 possible values. The obvious
 * theoretical maximum is 8cells-9values, but the chances of one of them being
 * useful is so low that we can just declare them all useless from the outset,
 * and not waste time collecting them in the first place. This matters because
 * AlmostLockedSet.findRccs processes exponentially: numALSs * numALSs, so the
 * less useless ALSs we find the faster it is, and speed is always good!
 *
 * @author Keith Corlett 2020 Apr
 */
public class DiufAls {

	/** The N+1 potential values as a bitset. */
	public final int maybes;
	/** The N cells. */
	public final Cell[] cells;
	/** The ARegion which houses this Almost Locked Set. */
	public final ARegion region;
	/** The indices of those N cells in Grid.cells[]. */
	public final Idx idx;

	/**
	 * Constructs a new ALS.
	 * <p>
	 * Note that I'm private coz I'm only called locally, via the adapter, so
	 * if you ever de-HoDoKu-ify ALSs then you'll need me package+ visible.
	 * @param maybes
	 * @param cells
	 * @param region
	 */
	public DiufAls(int maybes, Cell[] cells, ARegion region) {
		this.maybes = maybes;
		this.cells = cells;
		this.region = region;
		this.idx = new Idx(cells);
	}

	/**
	 * HoDoKuAdapter: Construct a new ALS from a HdkAls and the grid.
	 * <p>
	 * note: using grid.at effectively translates HdkSet -> cells -> Idx
	 * <p>
	 * note: clone the cached Cell[] from at. It will be overwritten!
	 *
	 * @param grid the current Grid we're solving, from which I get the cells
	 * in the set, because the hint doesn't have the grid, so it can't look
	 * them up itself. Maybe hints should have the grid. I was trying to keep
	 * the model out of the GUI, but the GUI needs cells (or atleast cell-like
	 * objects to paint them), and each cell holds an innate reference to the
	 * whole grid; So the hint may as well hold a reference to the grid. sigh.
	 *
	 * @param als the HoDoKu almost locked set
	 */
	public DiufAls(Grid grid, HdkAls als) {
		this(als.maybes, grid.at(als.set).clone(), als.region);
	}

	@Override
	public String toString() {
		return region.id+" "+idx+" {"+Values.toString(maybes)+"}";
	}

	/**
	 * The format method returns a human readable String representation of
	 * this DiufAls suitable for use in hint HTML.
	 *
	 * @return "region.id: cell.ids {maybes}"<br>
	 * Note that if region is null then "^[^:]+: " goes MIA.
	 */
	public String format() {
		return id(region)
			 + Frmt.and(cells)
			 + " {"+Values.toString(maybes, ", ", " and ")+"}";
	}
	private static String id(ARegion r) {
		return r==null ? "" : r.id + ": ";
	}

	@Override
	public boolean equals(Object obj) {
		if ( obj == this )
			return true;
		return obj != null
			&& obj instanceof DiufAls
			&& idx.equals(((DiufAls)obj).idx);
	}

	@Override
	public int hashCode() {
		return idx.hashCode();
	}

//not used
//	void cleanUp() {
//		if ( cells != null )
//			for ( int i=0,I=cells.length; i<I; ++i )
//				cells[i] = null;
//	}

}
