/*
 * Copyright (C) 2008-12  Bernhard Hobiger
 *
 * This file is part of HoDoKu.
 *
 * HoDoKu is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * HoDoKu is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with HoDoKu. If not, see <http://www.gnu.org/licenses/>.
 */

package diuf.sudoku.solver.hinters.als;
// Almost Locked Set from HoDoKu

import diuf.sudoku.Grid;
import java.util.List;


/**
 * HdkSet is HoDoKu's SudokuSet class, with minimal changes. The Idx class is
 * Sudoku Explainers logical equivalent, except I think HdkSet is faster!
 *
 * ENGLISH: HdkSet extends HdkSetBase (a bitset of indices of 81 grid cells)
 * to add a values array which allows us to iterate the set (1) bits in the
 * bitset relatively cleanly and cheaply: each iteration is O(2*n) end-to-end.
 *
 * GERMAN: Hilfsklasse für die Fischsuche:
 *
 * Ein SudokuSet ist ein Integer-Array der Größe 81, das Werte zwischen 0 und 81
 * aufnehmen kann. Die Werte innerhalb des Arrays werden sortiert eingefügt.
 *
 * Aus Performancegründen werden die Werte in einer Bitmask dupliziert. Operationen
 * wie merge() oder contains() können damit wesentlich schneller ausgeführt werden.
 * In der Bitmap wird der Wert "0" als "0x00000001" abgebildet. Der größte darstellbare
 * Wert pro int ist "0x80000000" und steht für "31", 3 int ergeben daher die Werte 0 - 95.
 * int mask1:  0 - 31
 * int mask2: 32 - 63
 * int mask3: 64 - 95
 *
 * Mehrere Instanzen von SudokuSet können miteinander verglichen werden. Speziell ist es
 * möglich zu prüfen, ob Werte eines SudokuSet in einem anderen enthalten sind. Außerdem
 * können effizient Vereinigungen von SudokuSets gebildet werden (entspricht mischen).
 *
 * @author hobiwan
 */
public class HdkSet extends HdkSetBase
		implements Cloneable
{
	private static final long serialVersionUID = 1L;

	// für jede der 256 möglichen Kombinationen von Bits das entsprechende Array
	private static final int[][] VALUESES = new int[256][8];
	// und zu jeder Zahl die Länge des Arrays
	public static final int[] SIZE = new int[256];

	static { // init VALUESES, and SIZES
		int cnt, bits, j;
		for ( int i=0; i<256; ++i ) {
			for ( cnt=0,j=0,bits=1; j<8; ++j,bits<<=1 )
				if ( (i & bits) != 0 )
					VALUESES[i][cnt++] = j;
			SIZE[i] = cnt;
		}
	}

	static HdkSet newAnd(HdkSetBase aa, HdkSetBase bb) {
		return new HdkSet(aa.m1&bb.m1, aa.m2&bb.m2);
	}

	static HdkSet newOr(HdkSet aa, HdkSet bb) {
		return new HdkSet(aa.m1|bb.m1, aa.m2|bb.m2);
	}

	// ============================ instance stuff ============================

	private int[] values = null;
	private int anz = 0;

	/** Creates a new instance of SudokuSet */
	public HdkSet() {
	}

	public HdkSet(HdkSetBase init) {
		super(init);
	}

	public HdkSet(boolean full) {
		super(full);
	}

	/**
	 * Copy Constructor: Constructs a new HdkSet of the given masks.
	 * @param mask1
	 * @param mask2
	 */
	public HdkSet(long mask1, long mask2) {
		super(mask1, mask2);
	}

	/**
	 * Constructor to turn AlsInSolutionStep.getIndices() back into a Set.
	 * @param indices
	 */
	public HdkSet(List<Integer> indices) {
		for ( Integer i : indices )
			add(i); // let it auto-unbox
		initialized = false;
	}

// not required, all this does is cost time: everything is it's default value!
//	@Override
//	public HdkSet clone() {
//		HdkSet newSet = (HdkSet) super.clone();
//		// dont clone values for performance, it may not be necessary.
//		values = null;
//		initialized = false;
//		return newSet;
//	}

	@Override
	public void clear() {
		super.clear();
		anz = 0;
	}

	/**
	 * Mutate this &= bb, ie set this to the conjuction of this Set and bb.
	 * @param bb
	 * @return this for method chaining
	 */
	@Override
	public HdkSet and(HdkSetBase bb) {
		return (HdkSet)super.and(bb);
	}

	/**
	 * Mutate this &= ~b, ie removes all elements in b from this Set.
	 * @param bb
	 * @return this for method chaining
	 */
	@Override
	public HdkSet andNot(HdkSetBase bb) {
		return (HdkSet)super.andNot(bb);
	}

	/**
	 * Append the string representation of this HdkSet to the given
	 * StringBuilder and return it for method chaining.
	 * @param sb
	 * @return 
	 */
	StringBuilder append(StringBuilder sb) {
		int mi, i, j,J;
		if ( m1 != 0 )
			for ( i=0; i<64; i+=8 ) {
				mi = (int)((m1>>i) & 0xFF); // masked index
				for ( j=0,J=SIZE[mi]; j<J; ++j )
					sb.append(Grid.CELL_IDS[VALUESES[mi][j]+i]);
			}
		if ( m2 != 0 )
			for ( i=0; i<24; i+=8 ) {
				mi = (int)((m2>>i) & 0xFF);
				for ( j=0,J=SIZE[mi]; j<J; ++j )
					sb.append(Grid.CELL_IDS[VALUESES[mi][j]+i+64]);
			}
		return sb;
	}

	private void initialize() {
		int mi, i, j,J, cnt=0;
		if ( values == null )
			values = new int[81];
		if ( m1 != 0 )
			for ( i=0; i<64; i+=8 ) {
				mi = (int)((m1>>i) & 0xFF); // masked index
				for ( j=0,J=SIZE[mi]; j<J; ++j )
					values[cnt++] = VALUESES[mi][j]+i;
			}
		if ( m2 != 0 )
			for ( i=0; i<24; i+=8 ) {
				mi = (int)((m2>>i) & 0xFF);
				for ( j=0,J=SIZE[mi]; j<J; ++j )
					values[cnt++] = VALUESES[mi][j]+i+64;
			}
		anz = cnt;
		initialized = true;
	}

	public int get(int index) {
		if ( !initialized )
			initialize();
		return values[index];
	}

	public int size() {
		if ( m1==0 && m2==0 ) // none
			return 0;
		if ( !initialized )
			initialize();
		return anz;
	}

	public int[] getValues() {
		if ( !initialized )
			initialize();
		return values;
	}

	@Override
	public String toString() {
		if ( !initialized )
			initialize();
		// cellIds is defined in my superclass
		return cellIds(values, anz);
//		return diuf.sudoku.utils.Frmt.ssv(anz, values);
	}

	diuf.sudoku.Idx toIdx() {
		// translate directly from HdkSet 64+17 bits to Idx 27+27+27 bits.
	    // the right 27 bits of m1
		int a0 = (int)( m1 & TWENTYSEVEN_BITS );
		// the second-right 27 bits of m1
		int a1 = (int)( (m1>>>27) & TWENTYSEVEN_BITS );
		// the left 10 bits of m1 left-shifted 17 ^ the 17 bits in m2
		int a2 = (int)( ((m1>>>54)<<17) ^ (m2 & SEVENTEEN_BITS) );
		// return a new Idx
		return new diuf.sudoku.Idx(a0, a1, a2);
	}
	private static final long TWENTYSEVEN_BITS = (1<<27)-1;
	private static final long SEVENTEEN_BITS = (1<<17)-1;

	/**
	 * DIUFAdapter: an implementation of Idx.toArrayA().
	 * @return a cached array of size values.
	 */
	int[] toArrayA() {
		final int n = size();
		// use Idx's IntArray-cache instead of creating new ones
		final int[] copy = diuf.sudoku.Idx.iasA[n];
		System.arraycopy(getValues(), 0, copy, 0, n);
		return copy;
	}

}
