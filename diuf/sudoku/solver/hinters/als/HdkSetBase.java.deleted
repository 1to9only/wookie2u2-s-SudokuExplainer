/*
 * Copyright (C) 2008-12  Bernhard Hobiger
 *
 * This file is part of HoDoKu.
 *
 * HoDoKu is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * HoDoKu is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with HoDoKu. If not, see <http://www.gnu.org/licenses/>.
 */

package diuf.sudoku.solver.hinters.als;
// Almost Locked Set from HoDoKu

import diuf.sudoku.Grid;
import java.io.Serializable;


/**
 * HoDoKu Base Set is a bitset index of the 81 cells in a Sudoku Grid. It's
 * extended by HdkSet to add an array of the set indices; but method chaining
 * is tricky on heritable methods, so I (mostly) left it out. Sigh.
 *
 * @author hobiwan
 */
public class HdkSetBase
		implements Cloneable, Serializable, Comparable<HdkSetBase>
{
	private static final long serialVersionUID = 1L;

	// ~~~~~~~~~~~~~~~~~~~~~~ static stuff ~~~~~~~~~~~~~~~~~~~~~~

	// the value of each possible element as a bitset.
	private static final long[] SHFT = {
		0x0000000000000001L, 0x0000000000000002L, 0x0000000000000004L, 0x0000000000000008L,
		0x0000000000000010L, 0x0000000000000020L, 0x0000000000000040L, 0x0000000000000080L,
		0x0000000000000100L, 0x0000000000000200L, 0x0000000000000400L, 0x0000000000000800L,
		0x0000000000001000L, 0x0000000000002000L, 0x0000000000004000L, 0x0000000000008000L,
		0x0000000000010000L, 0x0000000000020000L, 0x0000000000040000L, 0x0000000000080000L,
		0x0000000000100000L, 0x0000000000200000L, 0x0000000000400000L, 0x0000000000800000L,
		0x0000000001000000L, 0x0000000002000000L, 0x0000000004000000L, 0x0000000008000000L,
		0x0000000010000000L, 0x0000000020000000L, 0x0000000040000000L, 0x0000000080000000L,
		0x0000000100000000L, 0x0000000200000000L, 0x0000000400000000L, 0x0000000800000000L,
		0x0000001000000000L, 0x0000002000000000L, 0x0000004000000000L, 0x0000008000000000L,
		0x0000010000000000L, 0x0000020000000000L, 0x0000040000000000L, 0x0000080000000000L,
		0x0000100000000000L, 0x0000200000000000L, 0x0000400000000000L, 0x0000800000000000L,
		0x0001000000000000L, 0x0002000000000000L, 0x0004000000000000L, 0x0008000000000000L,
		0x0010000000000000L, 0x0020000000000000L, 0x0040000000000000L, 0x0080000000000000L,
		0x0100000000000000L, 0x0200000000000000L, 0x0400000000000000L, 0x0800000000000000L,
		0x1000000000000000L, 0x2000000000000000L, 0x4000000000000000L, 0x8000000000000000L
	};
	// the maximum value of m1: 64 1's
	private static final long MAX_MASK1 = 0xFFFFFFFFFFFFFFFFL;
	// the maximum value of m2: 17 1's
	private static final long MAX_MASK2 = 0x1FFFFL;

	/**
	 * Does s1 NOT intersect s2?
	 * @param s1
	 * @param s2
	 * @return (s1 & s2) == 0
	 */
	public static boolean andEmpty(HdkSetBase s1, HdkSetBase s2) {
		return (s1.m1 & s2.m1)==0 && (s1.m2 & s2.m2)==0;
	}

	/**
	 * Is s1 a superset of (contains all values in) s2?
	 * @param s1
	 * @param s2
	 * @return (s1.m1&s2.m1)==s2.m1 && (s1.m2&s2.m2)==s2.m2;
	 */
	public static boolean andEqualsS2(HdkSetBase s1, HdkSetBase s2) {
		return (s1.m1&s2.m1)==s2.m1 && (s1.m2&s2.m2)==s2.m2;
	}

	/**
	 * Is either set a superset of (contain all elements in) the other?
	 * @param s1
	 * @param s2
	 * @return (s1&s2)==s1 || (s1&s2)==s2
	 */
	public static boolean andEqualsEither(HdkSetBase s1, HdkSetBase s2) {
		// nb: I think it faster to & twice than set two new long vars, or call
		// a method twice (sigh)... pretty sure JIT can "inline" this and keeps
		// a&b in the registers (so doesn't actually need to calc it twice)
		return ((s1.m1&s2.m1)==s1.m1 && (s1.m2&s2.m2)==s1.m2)
			|| ((s1.m1&s2.m1)==s2.m1 && (s1.m2&s2.m2)==s2.m2);
	}

	/**
	 * Is either set a subset of the other?
	 * @param s1
	 * @param s2
	 * @return (s1|s2)==s1 || (s1|s2)==s2
	 */
	public static boolean orEqualsEither(HdkSetBase s1, HdkSetBase s2) {
		// nb: I think it faster to | twice than set two new long vars, or call
		// a method twice (sigh)... pretty sure JIT can "inline" this and keeps
		// a|b in the registers (so doesn't actually need to calc it twice)
		return ((s1.m1|s2.m1)==s1.m1 && (s1.m2|s2.m2)==s1.m2)
			|| ((s1.m1|s2.m1)==s2.m1 && (s1.m2|s2.m2)==s2.m2);
	}

	// ~~~~~~~~~~~~~~~~~~~~~~ instance stuff ~~~~~~~~~~~~~~~~~~~~~~

	/** Mask 1 - the lower order 64 bits of the 81 bit bitset. */
	public long m1 = 0; // 0..63
	/** Mask 2 - the higher order 17 bits of the 81 bit bitset. */
	public long m2 = 0; // 64..80
	/** Has this been initialised? */
	protected boolean initialized = true;

	// ~~~~~~~~~~~~~~~~~~~~~~ constructors ~~~~~~~~~~~~~~~~~~~~~~

	/** Constructs a new empty HdkSetBase. */
	public HdkSetBase() {
	}

	/**
	 * Copy Constructor: constructs a new HdkSetBase which contains a copy
	 * of init's contents.
	 * @param src
	 */
	public HdkSetBase(HdkSetBase src) {
		set(src);
	}

	/**
	 * Constructs a new HdkSetBase which is full if 'fill' is true, else
	 * an empty HdkSetBase.
	 * @param fill
	 */
	public HdkSetBase(boolean fill) {
		if ( fill )
			fill();
	}

	/**
	 * Copy Constructor: Constructs a new HdkSet of the given masks.
	 * @param mask1
	 * @param mask2
	 */
	public HdkSetBase(long mask1, long mask2) {
		m1 = mask1;
		m2 = mask2;
		initialized = false;
	}

// not required: everything is it's default value, so this just costs time.
//	/** Clone this instance of HdkSetBase by calling Object.clone().
//	 * @return a new HdkSetBase which is a shallow copy of this one, which is
//	 * all that is required because all my attributes are all native types.
//	 * Note that toStrings indices array is NOT copied, but that doesn't matter
//	 * because the first toString call (if any) on the copy will create and
//	 * populate his indices array.
//	 */
//	@Override
//	public HdkSetBase clone() {
//		HdkSetBase newSet = null;
//		try {
//			newSet = (HdkSetBase)super.clone();
//		} catch (CloneNotSupportedException ex) {
//			Logger.getLogger(getClass().getName()).log(Level.SEVERE, "Error cloning HdkSetBase", ex);
//		}
//		return newSet;
//	}

	// ~~~~~~~~~~~~~~~~~~~~~~ setters ~~~~~~~~~~~~~~~~~~~~~~
	// These set* methods all set the value of this HdkSetBase outright.
	// They overwrite any/all existing contents.

	/**
	 * Set this = b.
	 * <p>This method is final because it is called in constructor/s.
	 * @param b
	 * @return this for method chaining
	 */
	public final HdkSetBase set(HdkSetBase b) {
		m1 = b.m1;
		m2 = b.m2;
		initialized = false;
		return this;
	}

	/**
	 * The copy constructor: Sets this Set to given mask1 and mask2 values.
	 * @param m1
	 * @param m2
	 */
	public void set(long m1, long m2) {
		this.m1 = m1;
		this.m2 = m2;
		initialized = false;
	}

	/**
	 * Sets this = (s1 & s2)
	 * @param s1
	 * @param s2
	 * @return this for method chaining.
	 */
	public HdkSetBase setAnd(HdkSetBase s1, HdkSetBase s2) {
		m1 = (s1.m1 & s2.m1);
		m2 = (s1.m2 & s2.m2);
		initialized = false;
		return this;
	}

	/**
	 * Sets this = (s1 | s2).
	 * @param s1
	 * @param s2
	 * @return this for method chaining.
	 */
	public HdkSetBase setOr(HdkSetBase s1, HdkSetBase s2) {
		m1 = (s1.m1 | s2.m1);
		m2 = (s1.m2 | s2.m2);
		initialized = false;
		return this;
	}

	/**
	 * DIUFAdapter: set all indices except those in the given HdkSetBase.
	 * @param aa
	 * @return this HdkSetBase for method chaining
	 */
	HdkSetBase setAllExcept(HdkSetBase aa) {
		m1 = MAX_MASK1 & ~aa.m1;
		m2 = MAX_MASK2 & ~aa.m2;
		initialized = false;
		return this;
	}

	/**
	 * Fills this Set, ie sets all indices.
	 * <p>This method is final because it is called in constructor/s.
	 */
	public final void fill() {
		m1 = MAX_MASK1;
		m2 = MAX_MASK2;
		initialized = false;
	}

	/**
	 * Clears this Set, ie removes all indices.
	 */
	public void clear() {
		m1 = m2 = 0;
		initialized = false;
	}

	// ~~~~~~~~~~~~~~~~~~~~~~ mutators ~~~~~~~~~~~~~~~~~~~~~~
	// These mutator methods all respect the existing contents of this Set.
	// None of these methods set the masks absolutely, they only add/remove
	// to/from it.

	/**
	 * Adds value to this Set.
	 * @param value
	 */
	public void add(int value) {
		if (value < 64)
			m1 |= SHFT[value];
		else
			m2 |= SHFT[value - 64];
		initialized = false;
	}

	/**
	 * Removes value from this Set.
	 * @param value
	 */
	public void remove(int value) {
		if (value < 64)
			m1 &= ~SHFT[value];
		else
			m2 &= ~SHFT[value - 64];
		initialized = false;
	}

	/**
	 * Mutate this |= b.
	 * @param b
	 * @return
	 */
	public HdkSetBase or(HdkSetBase b) {
		m1 |= b.m1;
		m2 |= b.m2;
		initialized = false;
		return this;
	}

	/**
	 * Mutate this |= ~b, ie removes all elements in b from this Set.
	 * @param b
	 */
	public void orNot(HdkSetBase b) {
		m1 |= ~b.m1;
		m2 = (m2 | ~b.m2) & MAX_MASK2; // only 17 bits are used
		initialized = false;
	}

	/**
	 * Mutate this |= (s1 & s2), ie adds the intersection of s1 and s2 to this
	 * Set.
	 *
	 * @param s1
	 * @param s2
	 */
	public void orAndAnd(HdkSetBase s1, HdkSetBase s2) {
		m1 |= (s1.m1 & s2.m1);
		m2 |= (s1.m2 & s2.m2);
		initialized = false;
	}

	/**
	 * Mutate this &= b, ie sets this to the intersection of this and b,
	 * ie removes all elements of this set which are not in b.
	 * @param b
	 * @return This HdkSetBase for method chaining
	 */
	public HdkSetBase and(HdkSetBase b) {
		m1 &= b.m1;
		m2 &= b.m2;
		initialized = false;
		return this;
	}

	/**
	 * Mutate this &= ~b, ie removes all elements in b from this Set.
	 * @param b
	 * @return this for method chaining
	 */
	public HdkSetBase andNot(HdkSetBase b) {
		m1 &= ~b.m1;
		m2 &= ~b.m2;
		initialized = false;
		return this;
	}

	// ~~~~~~~~~~~~~~~~~~~~~~ queries ~~~~~~~~~~~~~~~~~~~~~~
	// None of these methods modify this Sets contents.

	/**
	 * Is this Set empty?
	 * @return m1==0 && m2==0;
	 */
	public boolean none() {
		return m1==0 && m2==0;
	}

	/**
	 * Does this Set contain anything?
	 * @return m1!=0 || m2!=0;
	 */
	boolean any() {
		return m1!=0 || m2!=0;
	}

	/**
	 * Does this Set contain the given value?
	 * @param value
	 * @return true if this Set contains the given value, else false.
	 */
	public boolean contains(int value) {
		if ( value < 64 )
			return (m1 & SHFT[value]) != 0;
		else
			return (m2 & SHFT[value-64]) != 0;
	}

	/**
	 * Does the intersection of this Set and b contain anything?<br>
	 * Ie does b intersect this Set?
	 * @param b
	 * @return (m1 & b.m1)!=0 || (m2 & b.m2)!=0;
	 */
	public boolean andAny(HdkSetBase b) {
		return (m1 & b.m1)!=0 || (m2 & b.m2)!=0;
	}

	/**
	 * Is the intersection of this Set and b empty?<br>
	 * Ie is b disjunct from this Set?
	 * @param b
	 * @return (m1 & b.m1)==0 && (m2 & b.m2)==0;
	 */
	public boolean andEmpty(HdkSetBase b) {
		return (m1 & b.m1)==0 && (m2 & b.m2)==0;
	}

	/**
	 * Does this Set contain all elements in b?
	 * @param b
	 * @return (b.m1 & ~m1)==0 && (b.m2 & ~m2)==0;
	 */
	public boolean contains(HdkSetBase b) {
		return (b.m1 & ~m1)==0 && (b.m2 & ~m2)==0;
	}

	/**
	 * Does b contain all elements in this Set?
	 * @param b
	 * @return (m1 & b.m1)==b.m1 && (m2 & b.m2)==b.m2;
	 */
	public boolean andEqualsThis(HdkSetBase b) {
		return (m1 & b.m1)==m1 && (m2 & b.m2)==m2;
	}

	/**
	 * Is b disjunct from this Set? Ie does b NOT contain any element of this
	 * Set?
	 * @param b
	 * @return (m1 & ~b.m1)==m1 && (m2 & ~b.m2)==m2;
	 */
	public boolean andNotEquals(HdkSetBase b) {
		return (m1 & ~b.m1)==m1 && (m2 & ~b.m2)==m2;
	}

	// ~~~~~~~~~~~~~~~~~~~~~~ plumbing ~~~~~~~~~~~~~~~~~~~~~~

	/**
	 * Returns less than zero if this should come before o in a sort,
	 * else greater than zero means this should come after o,
	 * else zero means there's no preference, so sort (usually) puts me first.
	 * @param o
	 * @return the difference in masks reduced to -1, 1, or 0.
	 */
	@Override
	public int compareTo(HdkSetBase o) {
		long diff;
		if ( (diff=m2 - o.m2) == 0 )
			diff = m1 - o.m1;
		return diff < 0 ? -1
			 : diff > 0 ? 1
			 : 0;
	}

	@Override
	public boolean equals(Object o) {
		return o!=null && (o instanceof HdkSetBase) && equals((HdkSetBase)o);
	}
	// Note that s is presumed to be not null!
	public boolean equals(HdkSetBase s) {
		return m1==s.m1 && m2==s.m2;
	}

	@Override
	public int hashCode() {
		// only the lower-order 32 (actually 17) bits of m2 are populated,
		// so we fold the top half of m1 over the bottom half, and then or-in
		// the populated 17 bits of m2, giving us (I think) a reasonably
		// distinctive hashCode for each possible Idx.
		return (int) (this.m1 ^ (this.m1>>>32) ^ this.m2);
	}

	/**
	 * Returns a space-separated String of the cell.id's at my indices.
	 */
	@Override
	public String toString() {
		// recreate indices (a local HdkSet.initialize()).
		if ( indices == null )
			indices = new int[81];
		int cnt = 0;
		for ( int i=0; i<64; ++i )
			if ( (m1 & SHFT[i]) != 0 )
				indices[cnt++] = i;
		for ( int i=0; i<17; ++i )
			if ( (m2 & SHFT[i]) != 0 )
				indices[cnt++] = i + 64;
		// then we return the same cellIds method as HdkSet (my subclass)
		if ( true ) // @check true
			return cellIds(indices, cnt);
		else // debug only
			return diuf.sudoku.utils.Frmt.ssv(cnt, indices);
	}
	private int[] indices;

	/**
	 * Returns a space-separated String of the id's of the cells at the first
	 * 'n' indices.
	 * <p>nb: I'm static: pass me your relevant instance attributes.
	 * <p>nb: If you want me publicly then go ahead and make me public.
	 * @param indices contains Grid.cell indices of the cells in your set
	 * @param n the number of indices actually in the indices array, which may
	 *  be &lt;= indices.length when you're using a "larger" reusable array.
	 * @return space-separated cell.id's
	 */
	protected static String cellIds(int[] indices, int n) {
		if ( n == 0 )
			return "-";
		final String[] ids = Grid.CELL_IDS;
		final StringBuilder sb = getSB(n * (Grid.CELL_ID_LENGTH+1));
		sb.append(ids[indices[0]]);
		for ( int i=1; i<n; ++i )
			sb.append(' ').append(ids[indices[i]]);
		return sb.toString();
	}
	protected static StringBuilder getSB(int capacity) {
		if ( SB == null )
			return SB = new StringBuilder(capacity);
		SB.setLength(0);
		if ( capacity > SB.capacity() )
			SB.ensureCapacity(capacity);
		return SB;
	}
	// All the Hdk(Base)Set's use a single SB, which'll seen get big enough to
	// handle the largest of them, so no wasting time on memory management.
	protected static StringBuilder SB;

}
